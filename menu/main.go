package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"

	"github.com/JoshuaDoes/json"
	flag "github.com/spf13/pflag"
)

var (
	workingDir         string //where the menu should treat as its working directory
	configFile         string //path to menu configuration
	keyCalibrationFile string //path to keyboard calibration, can be written for embedded devices or generated by first run calibrator
	hLines             int    //horizontal lines for screen
	vLines             int    //vertical lines for screen

	keyCalibration map[string][]*MenuKeycodeBinding = make(map[string][]*MenuKeycodeBinding)
	menuConfig     *MenuConfig                      //menu configuration
	menuEngine     *MenuEngine                      //menu engine/runtime/???
)

type MenuConfig struct {
	Environment map[string]string                `json:"environment"`
	HomeMenu    string                           `json:"homeMenu"`
	Menus       map[string]*MenuItemList         `json:"menus"`
	Keyboards   map[string][]*MenuKeycodeBinding `json:"keyboards"`
}

func init() {
	//Apply all command-line flags
	flag.StringVar(&workingDir, "workingDir", "", "path to treat as working directory")
	flag.StringVar(&configFile, "menu", "", "path to menu configuration")
	flag.StringVar(&keyCalibrationFile, "keyCalibration", "", "path to keyboard calibration, generated by calibrator if not present")
	flag.IntVar(&hLines, "hLines", 0, "horizontal lines available to virtual screen")
	flag.IntVar(&vLines, "vLines", 0, "vertical lines available to virtual screen")
	flag.Parse()

	if workingDir == "" {
		workingDir, _ = os.Getwd()
	}
	if configFile == "" {
		configFile = workingDir + "/menu.json"
	}
	if keyCalibrationFile == "" {
		keyCalibrationFile = workingDir + "/keyCalibration.json"
	}
	if hLines <= 0 {
		hLines = 30
	}
	if vLines <= 0 {
		vLines = 100
	}

	configJSON, err := ioutil.ReadFile(configFile)
	if err != nil {
		panic(fmt.Sprintf("error reading config file: %v", err))
	}

	menuConfig = &MenuConfig{}
	err = json.Unmarshal(configJSON, menuConfig)
	if err != nil {
		panic(fmt.Sprintf("error parsing config file: %v", err))
	}

	menuEngine = NewMenuEngine(render, hLines, vLines)
	menuEngine.Environment = menuConfig.Environment
	menuEngine.Environment["WORKINGDIR"] = workingDir
	menuEngine.Environment["WD"] = workingDir

	for id, itemList := range menuConfig.Menus {
		menuEngine.AddMenu(id, itemList)
	}

	menuEngine.HomeMenu = menuConfig.HomeMenu
}

func main() {
	calibrate()
	clear(10)

	menuEngine.Home()
	bindKeys()

	sc := make(chan os.Signal, 1)
	signal.Notify(sc, syscall.SIGINT)
	<-sc
}

func clear(delay time.Duration) {
	for lines := 0; lines < menuEngine.LinesV; lines++ {
		fmt.Printf("\n")
		if delay > 0 {
			time.Sleep(delay * time.Millisecond)
		}
	}
}

func render(menu string) {
	//clear(0)
	for i := 0; i < vLines; i++ {
		fmt.Printf("\n")
	}
	menuLines := strings.Split(menu, "\n")
	for i := 0; i < len(menuLines); i++ {
		fmt.Printf("\t\t%s\n", menuLines[i])
	}
	fmt.Printf("\n")
}
